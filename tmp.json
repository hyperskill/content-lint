{
  "name": "pycharm",
  "text": "<h5 id=\"description\" style=\"text-align: center;\">Description</h5>\n<p>In this project, you'll write a game called Tic-Tac-Toe that you can play against your computer. The computer will have three levels of difficulty \u2014 easy, medium, and hard.</p>\n<p>To begin with, let's write a program that knows how to work with coordinates and determine the state of the game.</p>\n<p>The top-left cell will have the coordinates (1, 1) and the bottom-right cell will have the coordinates (3, 3), as shown in this table:</p>\n<p><samp>(1, 1) (1, 2) (1, 3)<br/>\n(2, 1) (2, 2) (2, 3)<br/>\n(3, 1) (3, 2) (3, 3)</samp></p>\n<p>The program should ask the user to enter the coordinates of the cell where they want to make a move.</p>\n<p>Keep in mind that the first coordinate goes from top to bottom, and the second coordinate goes from left to right. Also, notice that coordinates start with 1 and can be 1, 2, or 3.</p>\n<p>But what if the user attempts to enter invalid coordinates? This could happen if they try to enter letters or symbols instead of numbers, or the coordinates of an already occupied cell. Your program needs to prevent these things from happening by checking the user's input and catching possible exceptions.</p>\n<h5 id=\"objectives\" style=\"text-align: center;\">Objectives</h5>\n<p>The program should work in the following way:</p>\n<ol>\n<li>Ask the user to provide the initial state of the 3x3 table with the first input line. This must include nine symbols that can be <code class=\"java\">X</code>, <code class=\"java\">O</code> or <code class=\"java\">_</code> (the latter represents an empty cell).</li>\n<li>Output the specified 3x3 table before the user makes a move.</li>\n<li>Request that the user enters the coordinates of the move they wish to make.</li>\n<li>The user then inputs two numbers representing the cell in which they wish to place their <code class=\"java\">X</code> or <code class=\"java\">O</code>. The game always starts with <code class=\"java\">X</code>, so the user's move should be made with this symbol if there are an equal number of <code class=\"java\">X</code>'s and <code class=\"java\">O</code>'s in the table. If the table contains an extra <code class=\"java\">X</code>, the move should be made with <code class=\"java\">O</code>.</li>\n<li>Analyze the user input and show messages in the following situations:<br/>\n\t\u2022 <code class=\"java\">This cell is occupied! Choose another one!</code> \u2014 if the cell is not empty;<br/>\n\t\u2022 <code class=\"java\">You should enter numbers!</code> \u2014 if the user tries to enter letters or symbols instead of numbers;<br/>\n\t\u2022 <code class=\"java\">Coordinates should be from 1 to 3!</code> \u2014 if the user attempts to enter coordinates outside of the table's range.</li>\n<li>Display the table again with the user's most recent move included.</li>\n<li>Output the state of the game.</li>\n</ol>\n<p>The possible states are:</p>\n<ul>\n<li><code class=\"java\">Game not finished</code> \u2014 when no side has three in a row, but the table still has empty cells;</li>\n<li><code class=\"java\">Draw</code> \u2014 when no side has three in a row, and the table is complete;</li>\n<li><code class=\"java\">X wins</code> \u2014 when there are three <code class=\"java\">X</code>'s in a row (up, down, across, or diagonally);</li>\n<li><code class=\"java\">O wins</code> \u2014 when there are three <code class=\"java\">O</code>'s in a row (up, down, across, or diagonally).</li>\n</ul>\n<p>If the user provides invalid coordinates, the program should repeat the request until numbers that represent an empty cell on the table are supplied. You should ensure that the program only outputs the table twice \u2014 before the move and after the user makes a legal move.</p>\n<h5 id=\"examples\" style=\"text-align: center;\">Examples</h5>\n<p>The examples below show how your program should work.<br/>\nThe greater-than symbol followed by a space (<code class=\"java\">&gt; </code>) represents the user input. Note that it's not part of the input.</p>\n<p><strong>Example 1:</strong></p>\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; _XXOO_OX_\n---------\n|   X X |\n| O O   |\n| O X   |\n---------\nEnter the coordinates: &gt; 3 1\nThis cell is occupied! Choose another one!\nEnter the coordinates: &gt; one\nYou should enter numbers!\nEnter the coordinates: &gt; one three\nYou should enter numbers!\nEnter the coordinates: &gt; 4 1\nCoordinates should be from 1 to 3!\nEnter the coordinates: &gt; 1 1\n---------\n| X X X |\n| O O   |\n| O X   |\n---------\nX wins</code></pre>\n<p><strong>Example 2: </strong></p>\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; XX_XOXOO_\n---------\n| X X   |\n| X O X |\n| O O   |\n---------\nEnter the coordinates: &gt; 3 3\n---------\n| X X   |\n| X O X |\n| O O O |\n---------\nO wins</code></pre>\n<p><strong>Example 3: </strong></p>\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; OX_XOOOXX\n---------\n| O X   |\n| X O O |\n| O X X |\n---------\nEnter the coordinates: &gt; 1 3\n---------\n| O X X |\n| X O O |\n| O X X |\n---------\nDraw</code></pre>\n<p><strong>Example 4:</strong></p>\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt;  _XO_OX___\n---------\n|   X O |\n|   O X |\n|       |\n---------\nEnter the coordinates: &gt; 3 1\n---------\n|   X O |\n|   O X |\n| X     |\n---------\nGame not finished</code></pre>",
  "video": null,
  "options": {
    "task_type": "edu",
    "lesson_type": "framework",
    "title": "stage1",
    "description_text": "<h2 style=\"text-align: center;\">Description</h2>\n\n<p>In this project, you'll write a game called Tic-Tac-Toe that you can play against your computer. The computer will have three levels of difficulty \u2014 easy, medium, and hard.</p>\n\n<p>To begin with, let's write a program that knows how to work with coordinates and determine the state of the game.</p>\n\n<p>The top-left cell will have\u00a0the coordinates (1, 1) and the bottom-right cell will have the coordinates (3, 3), as shown\u00a0in this table:</p>\n\n<p><samp>(1, 1) (1, 2) (1, 3)<br>\n(2, 1) (2, 2) (2, 3)<br>\n(3, 1) (3, 2) (3, 3)</samp></p>\n\n<p>The program should ask the user to enter the coordinates of the cell where they want to make a move.</p>\n\n<p>Keep in mind that the first coordinate\u00a0goes from top to bottom, and the second coordinate goes from left to right. Also, notice that coordinates start with 1 and can be 1, 2, or 3.</p>\n\n<p>But what if the user attempts to enter\u00a0invalid\u00a0coordinates? This could happen if they try\u00a0to\u00a0enter letters or symbols instead of numbers, or the coordinates of an already\u00a0occupied cell. Your program needs to prevent these\u00a0things from happening by checking the\u00a0user's input and catching possible exceptions.</p>\n\n<h2 style=\"text-align: center;\">Objectives</h2>\n\n<p>The program should work in the following way:</p>\n\n<ol>\n\t<li>Ask the user to provide the initial state of the 3x3 table with the first input line. This\u00a0must include nine\u00a0symbols that can be\u00a0<code>X</code>, <code>O</code>\u00a0or\u00a0<code>_</code>\u00a0(the\u00a0latter represents an empty cell).</li>\n\t<li>Output the specified\u00a03x3 table before the user makes a\u00a0move.</li>\n\t<li>Request that the user enters the coordinates of the move they wish to make.</li>\n\t<li>The user then\u00a0inputs two numbers representing the cell in which they wish to place their\u00a0<code>X</code> or <code>O</code>. The game always starts with <code>X</code>, so the user's move should be made with this symbol if there are\u00a0an equal number of <code>X</code>'s and <code>O</code>'s in the table. If the table contains\u00a0an extra\u00a0<code>X</code>, the\u00a0move should be made with\u00a0<code>O</code>.</li>\n\t<li>Analyze the user input and show messages in the following situations:<br>\n\t\u2022\u00a0<code>This cell is occupied! Choose another one!</code>\u00a0\u2014 if the cell is not empty;<br>\n\t\u2022\u00a0<code>You should enter numbers!</code>\u00a0\u2014 if the user tries to enter letters or symbols instead of numbers;<br>\n\t\u2022\u00a0<code>Coordinates should be from 1 to 3!</code>\u00a0\u2014 if the user attempts to enter coordinates outside of the table's range.</li>\n\t<li>Display the table again with the user's most recent move included.</li>\n\t<li>Output the\u00a0state of the game.</li>\n</ol>\n\n<p>The possible states are:</p>\n\n<ul>\n\t<li><code>Game not finished</code>\u00a0\u2014 when no side has three in a row, but the table still\u00a0has empty cells;</li>\n\t<li><code>Draw</code>\u00a0\u2014 when no side has three in a row, and the table is complete;</li>\n\t<li><code>X wins</code>\u00a0\u2014 when there are three <code>X</code>'s in a row (up, down, across, or diagonally);</li>\n\t<li><code>O wins</code>\u00a0\u2014 when there are three <code>O</code>'s in a row (up, down, across, or diagonally).</li>\n</ul>\n\n<p>If the user provides invalid\u00a0coordinates, the program should repeat the request until numbers that represent an empty cell on the table are supplied.\u00a0You should ensure that the program only outputs the table twice \u2014 before the move and after the user makes a legal move.</p>\n\n<h2 style=\"text-align: center;\">Examples</h2>\n\n<p>The examples below show how your program should work.<br>\nThe greater-than symbol followed by a space (<code>&gt;\u00a0</code>) represents the user input. Note that it's not part of the input.</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; _XXOO_OX_\n---------\n|   X X |\n| O O   |\n| O X   |\n---------\nEnter the coordinates: &gt; 3 1\nThis cell is occupied! Choose another one!\nEnter the coordinates: &gt; one\nYou should enter numbers!\nEnter the coordinates: &gt; one three\nYou should enter numbers!\nEnter the coordinates: &gt; 4 1\nCoordinates should be from 1 to 3!\nEnter the coordinates: &gt; 1 1\n---------\n| X X X |\n| O O   |\n| O X   |\n---------\nX wins</code></pre>\n\n<p><strong>Example 2:\u00a0</strong></p>\n\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; XX_XOXOO_\n---------\n| X X   |\n| X O X |\n| O O   |\n---------\nEnter the coordinates: &gt; 3 3\n---------\n| X X   |\n| X O X |\n| O O O |\n---------\nO wins</code></pre>\n\n<p><strong>Example 3:\u00a0</strong></p>\n\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; OX_XOOOXX\n---------\n| O X   |\n| X O O |\n| O X X |\n---------\nEnter the coordinates: &gt; 1 3\n---------\n| O X X |\n| X O O |\n| O X X |\n---------\nDraw</code></pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt;  _XO_OX___\n---------\n|   X O |\n|   O X |\n|       |\n---------\nEnter the coordinates: &gt; 3 1\n---------\n|   X O |\n|   O X |\n| X     |\n---------\nGame not finished</code></pre>",
    "description_format": "HTML",
    "files": [
      {
        "name": "test/__init__.py",
        "placeholders": [],
        "is_visible": false,
        "text": ""
      },
      {
        "name": "test/tests.py",
        "placeholders": [],
        "is_visible": false,
        "text": "from hstest import CheckResult, StageTest, dynamic_test, TestedProgram\n\nfrom util.grid import Grid\n\n\nclass Test:\n    def __init__(self, inp, result, state, additional_contains=None):\n        self.inp = inp\n        self.result = result\n        self.state = state\n        self.additional_contains = additional_contains\n\n\nclass TicTacToeTests(StageTest):\n    test_cases = [\n        Test(\"_XXOO_OX_\\n1 1\", \"XXXOO_OX_\", \"X wins\"),\n        Test(\"_XXOO_OX_\\n1 3\\n1 1\", \"XXXOO_OX_\", \"X wins\", \"This cell is occupied! Choose another one!\"),\n        Test(\"_XXOO_OX_\\n1 4\\n1 1\", \"XXXOO_OX_\", \"X wins\", \"Coordinates should be from 1 to 3!\"),\n        Test(\"_XXOO_OX_\\none\\n1 1\", \"XXXOO_OX_\", \"X wins\", \"You should enter numbers!\"),\n        Test(\"_XXOO_OX_\\none three\\n1 1\", \"XXXOO_OX_\", \"X wins\", \"You should enter numbers!\"),\n        Test(\"_XXOO_OX_\\n2 3\", \"_XXOOXOX_\", \"Game not finished\"),\n        Test(\"_XXOO_OX_\\n3 3\", \"_XXOO_OXX\", \"Game not finished\"),\n        Test(\"XX_XOXOO_\\n1 3\", \"XXOXOXOO_\", \"O wins\"),\n        Test(\"XX_XOXOO_\\n3 3\", \"XX_XOXOOO\", \"O wins\"),\n        Test(\"_XO_OX___\\n1 1\", \"XXO_OX___\", \"Game not finished\"),\n        Test(\"_XO_OX___\\n2 1\", \"_XOXOX___\", \"Game not finished\"),\n        Test(\"_XO_OX___\\n3 1\", \"_XO_OXX__\", \"Game not finished\"),\n        Test(\"_XO_OX___\\n3 2\", \"_XO_OX_X_\", \"Game not finished\"),\n        Test(\"_XO_OX___\\n3 3\", \"_XO_OX__X\", \"Game not finished\"),\n        Test(\"_XO_OX__X\\n1 1\", \"OXO_OX__X\", \"Game not finished\"),\n        Test(\"_XO_OX__X\\n2 1\", \"_XOOOX__X\", \"Game not finished\"),\n        Test(\"_XO_OX__X\\n3 1\", \"_XO_OXO_X\", \"O wins\"),\n        Test(\"_XO_OX__X\\n3 2\", \"_XO_OX_OX\", \"Game not finished\"),\n        Test(\"XO_OXOX__\\n1 3\", \"XOXOXOX__\", \"X wins\"),\n        Test(\"XO_OXOX__\\n3 2\", \"XO_OXOXX_\", \"Game not finished\"),\n        Test(\"XO_OXOX__\\n3 3\", \"XO_OXOX_X\", \"X wins\"),\n    ]\n\n    @dynamic_test(data=test_cases)\n    def test_grid_output(self, test):\n        program = TestedProgram()\n        program.start()\n\n        output = program.execute(test.inp)\n\n        grid = Grid.from_line(test.inp.split('\\n')[0])\n        output_grid = Grid.from_output(output)\n\n        if grid != output_grid:\n            return CheckResult.wrong(\"The printed grid is not equal to the input grid!\\n\"\n                                     \"Correct grid:\\n\\n\" + str(grid))\n\n        if test.additional_contains is not None and test.additional_contains not in output:\n            return CheckResult.wrong(\"'{}' expected in the output!\".format(test.additional_contains))\n\n        result_grid = Grid.from_output(output, 2)\n        correct_result_grid = Grid.from_line(test.result)\n\n        if result_grid != correct_result_grid:\n            return CheckResult.wrong(\n                f\"The printed result grid is not correct!\\nCorrect result grid:\\n\\n {correct_result_grid}\")\n\n        if test.state not in output:\n            return CheckResult.wrong(f\"The game result is wrong. Expected result '{test.state}'\")\n\n        return CheckResult.correct()\n\n\nif __name__ == '__main__':\n    TicTacToeTests().run_tests()\n"
      },
      {
        "name": "tests.py",
        "placeholders": [],
        "is_visible": false,
        "text": "from test.tests import TicTacToeTests\n\nif __name__ == '__main__':\n    TicTacToeTests().run_tests()\n"
      },
      {
        "name": "tictactoe.py",
        "placeholders": [],
        "is_visible": true,
        "text": "# write your code here\n"
      }
    ],
    "samples": null,
    "execution_memory_limit": null,
    "execution_time_limit": null,
    "limits": null,
    "code_templates": null,
    "format_version": 16,
    "custom_name": "stage1",
    "solution_hidden": null,
    "code_templates_header_lines_count": null,
    "code_templates_footer_lines_count": null,
    "hyperskill": {
      "files": [
        {
          "name": "util/__init__.py",
          "is_visible": true,
          "text": ""
        },
        {
          "name": "util/enum.py",
          "is_visible": true,
          "text": "from enum import Enum\nfrom hstest import WrongAnswer\n\n\nclass GameState(Enum):\n    X_WIN = 'X_WIN'\n    O_WIN = 'O_WIN'\n    DRAW = 'DRAW'\n    NOT_FINISHED = 'NOT_FINISHED'\n\n\nclass CellState(Enum):\n    X = 'X'\n    O = 'O'\n    EMPTY = ' '\n\n    @classmethod\n    def get(cls, char: str):\n\n        char_to_cell_state = {\n            'X': cls.X,\n            'O': cls.O,\n            ' ': cls.EMPTY,\n            '_': cls.EMPTY\n        }\n\n        if char not in char_to_cell_state:\n            raise WrongAnswer('Bad symbol ' + char + ' in the game grid')\n        return char_to_cell_state[char]\n\n    @classmethod\n    def get_opponent(cls, player):\n        if player == CellState.X:\n            return CellState.O\n        if player == CellState.O:\n            return CellState.X\n        raise Exception('Wrong method argument!')\n"
        },
        {
          "name": "util/grid.py",
          "is_visible": true,
          "text": "from hstest import WrongAnswer\nfrom util.minimax import Position\nfrom util.enum import CellState, GameState\nfrom copy import copy\n\n\nclass Grid:\n    def __init__(self):\n        self.__grid = [[CellState.EMPTY for _ in range(3)] for _ in range(3)]\n\n    def get_grid(self):\n        return self.__grid\n\n    @classmethod\n    def from_line(cls, line):\n        if len(line) != 9:\n            raise WrongAnswer(\"Wrong input length. Expected 9.\\nFound \" + str(len(line)))\n\n        grid = Grid()\n\n        for i, char in enumerate(line):\n            grid.__grid[(int(i / 3))][i % 3] = CellState.get(char)\n\n        return grid\n\n    @classmethod\n    def from_output(cls, string_field: str, field_number: int = 1):\n        grid = Grid()\n\n        field_lines = list(map(str.strip, string_field.splitlines()))\n        field_lines = list(filter(lambda field_line:\n                                  str(field_line).startswith('|') and str(field_line).endswith('|'),\n                                  field_lines))\n\n        if len(field_lines) < 3 * field_number:\n            raise WrongAnswer(\"Expected not less than \" + str(field_number) + \" grids in the output!\\n\" +\n                              \"Make sure you print the game grids in the correct format!\")\n\n        field_lines = field_lines[field_number * 3 - 3:field_number * 3]\n\n        for i, line in enumerate(field_lines):\n            if len(line) != 9:\n                raise WrongAnswer(\"Can't parse the game field. The following line has wrong length:\\n\" + line)\n            for j in range(3):\n                grid.__grid[i][j] = CellState.get(line[j * 2 + 2])\n\n        return grid\n\n    @classmethod\n    def all_grids_from_output(cls, string_field: str):\n\n        grid_list = list()\n\n        field_lines = list(map(str.strip, string_field.splitlines()))\n        field_lines = list(filter(lambda field_line:\n                                  str(field_line).startswith('|') and str(field_line).endswith('|'),\n                                  field_lines))\n\n        if len(field_lines) % 3 != 0:\n            raise WrongAnswer(\n                \"Wrong grid output format! Each grid should contain 3 lines that starts and ends with '|' symbol!\")\n\n        for i in range(len(field_lines) // 3):\n            grid_lines = field_lines[i * 3:i * 3 + 3]\n\n            grid = Grid()\n\n            for j, line in enumerate(grid_lines):\n                if len(line) != 9:\n                    raise WrongAnswer(\"Can't parse the game field. The following line has wrong length:\\n\" + line)\n                for k in range(3):\n                    grid.__grid[j][k] = CellState.get(line[k * 2 + 2])\n\n            grid_list.append(grid)\n\n        return grid_list\n\n    @classmethod\n    def get_move(cls, from_grid, to_grid):\n        for i in range(3):\n            for j in range(3):\n                if from_grid.__grid[i][j] != to_grid.__grid[i][j]:\n                    return Position(i, j)\n        raise WrongAnswer(\"After making a move the grid was the same!\")\n\n    def is_win(self, player) -> bool:\n        for i in range(3):\n            if self.__grid[i][0] == self.__grid[i][1] and self.__grid[i][1] == self.__grid[i][2] and self.__grid[i][\n                2] == player:\n                return True\n\n        for i in range(3):\n            if self.__grid[0][i] == self.__grid[1][i] and self.__grid[1][i] == self.__grid[2][i] and self.__grid[2][\n                i] == player:\n                return True\n\n        return (self.__grid[0][0] == self.__grid[1][1] and self.__grid[1][1] == self.__grid[2][2] and self.__grid[2][\n            2] == player) or (self.__grid[2][0] == self.__grid[1][1] and self.__grid[1][1] == self.__grid[0][2] and\n                              self.__grid[0][2] == player)\n\n    def has_empty_cells(self):\n        for cells in self.__grid:\n            for cell in cells:\n                if cell == CellState.EMPTY:\n                    return True\n\n    def get_num_of_empty_cells(self):\n        result = 0\n        for cells in self.__grid:\n            for cell in cells:\n                if cell == CellState.EMPTY:\n                    result += 1\n        return result\n\n    def get_game_state(self):\n        if self.is_win(CellState.X):\n            return GameState.X_WIN\n        if self.is_win(CellState.O):\n            return GameState.O_WIN\n        if self.has_empty_cells():\n            return GameState.NOT_FINISHED\n        return GameState.DRAW\n\n    def set_cell(self, x, y, cell_state):\n        self.__grid[x][y] = cell_state\n\n    def is_correct_next_grid(self, grid):\n        return self.get_num_of_empty_cells() - grid.get_num_of_empty_cells() == 1\n\n    def is_valid_grid(self):\n        num_of_o = 0\n        num_of_x = 0\n        for cells in self.__grid:\n            for cell in cells:\n                if cell == CellState.O:\n                    num_of_o += 1\n                elif cell == CellState.X:\n                    num_of_x += 1\n        return abs(num_of_x - num_of_o) <= 1\n\n    @classmethod\n    def check_grid_sequence(cls, grids):\n\n        if len(grids) <= 1:\n            return\n\n        for i in range(1, len(grids) - 1):\n            prev_grid = grids[i - 1]\n            grid = grids[i]\n\n            if not grid.is_valid_grid():\n                raise WrongAnswer(\n                    \"Impossible grid was printed! The difference between Os and Xs in the grid is greater than 1:\\n\" + str(\n                        grid))\n\n            if not prev_grid.is_correct_next_grid(grid):\n                raise WrongAnswer(\"After making a move on grid\\n\" + str(prev_grid) + \"\\n it can't become\\n\" + str(grid))\n\n            last_grid = grids[-1]\n\n            if last_grid.get_game_state() == GameState.NOT_FINISHED:\n                raise WrongAnswer(\"Last grid is not terminal!\\n\" + str(last_grid))\n\n    def __str__(self):\n        result = '---------\\n'\n        for cell in self.__grid:\n            result += '| {} {} {} |\\n'.format(cell[0].value, cell[1].value, cell[2].value)\n        result += '---------'\n        return result\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return False\n\n        for i in range(9):\n            if self.__grid[int(i / 3)][i % 3] != other.__grid[int(i / 3)][i % 3]:\n                return False\n        return True\n"
        },
        {
          "name": "util/minimax.py",
          "is_visible": true,
          "text": "from util.enum import GameState, CellState\n\n\nclass Position:\n\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return str(self.x) + \" \" + str(self.y)\n\n    def __eq__(self, other):\n        return other.x == self.x and other.y == self.y\n\n\nclass Minimax:\n\n    @classmethod\n    def minimax(cls, grid, player, is_maximize, start_player, depth):\n\n        game_state = grid.get_game_state()\n\n        if game_state == GameState.X_WIN:\n            return 10 - depth if start_player == CellState.X else depth - 10\n        elif game_state == GameState.O_WIN:\n            return 10 - depth if start_player == CellState.O else depth - 10\n        elif game_state == GameState.DRAW:\n            return 0\n\n        best_score = -999 if is_maximize else 999\n\n        for i in range(3):\n            for j in range(3):\n                if grid.get_grid()[i][j] == CellState.EMPTY:\n                    grid.set_cell(i, j, player)\n                    score = cls.minimax(grid, CellState.get_opponent(player), not is_maximize, start_player, depth + 1)\n                    grid.set_cell(i, j, CellState.EMPTY)\n                    best_score = max(best_score, score) if is_maximize else min(best_score, score)\n\n        return best_score\n\n    @classmethod\n    def get_move(cls, grid, player):\n        best_score = -999\n        best_position = None\n\n        for i in range(3):\n            for j in range(3):\n                if grid.get_grid()[i][j] == CellState.EMPTY:\n                    grid.set_cell(i, j, player)\n                    score = cls.minimax(grid, CellState.get_opponent(player), False, player, 1)\n                    grid.set_cell(i, j, CellState.EMPTY)\n                    if score > best_score:\n                        best_score = score\n                        best_position = Position(i, j)\n\n        return best_position\n\n    @classmethod\n    def get_available_positions(cls, grid, player):\n\n        positions = list()\n\n        for i in range(3):\n            for j in range(3):\n                if grid.get_grid()[i][j] == CellState.EMPTY:\n                    grid.set_cell(i, j, player)\n                    score = cls.minimax(grid, CellState.get_opponent(player), False, player, 1)\n                    if score >= 0:\n                        positions.append(Position(i, j))\n                    grid.set_cell(i, j, CellState.EMPTY)\n\n        return positions\n"
        },
        {
          "name": "requirements.txt",
          "is_visible": true,
          "text": "https://github.com/hyperskill/hs-test-python/archive/release.tar.gz\n"
        }
      ]
    },
    "language": "python"
  },
  "subtitle_files": [],
  "source": {
    "task_type": "edu",
    "lesson_type": "framework",
    "title": "stage1",
    "description_text": "<h2 style=\"text-align: center;\">Description</h2>\n\n<p>In this project, you'll write a game called Tic-Tac-Toe that you can play against your computer. The computer will have three levels of difficulty \u2014 easy, medium, and hard.</p>\n\n<p>To begin with, let's write a program that knows how to work with coordinates and determine the state of the game.</p>\n\n<p>The top-left cell will have\u00a0the coordinates (1, 1) and the bottom-right cell will have the coordinates (3, 3), as shown\u00a0in this table:</p>\n\n<p><samp>(1, 1) (1, 2) (1, 3)<br>\n(2, 1) (2, 2) (2, 3)<br>\n(3, 1) (3, 2) (3, 3)</samp></p>\n\n<p>The program should ask the user to enter the coordinates of the cell where they want to make a move.</p>\n\n<p>Keep in mind that the first coordinate\u00a0goes from top to bottom, and the second coordinate goes from left to right. Also, notice that coordinates start with 1 and can be 1, 2, or 3.</p>\n\n<p>But what if the user attempts to enter\u00a0invalid\u00a0coordinates? This could happen if they try\u00a0to\u00a0enter letters or symbols instead of numbers, or the coordinates of an already\u00a0occupied cell. Your program needs to prevent these\u00a0things from happening by checking the\u00a0user's input and catching possible exceptions.</p>\n\n<h2 style=\"text-align: center;\">Objectives</h2>\n\n<p>The program should work in the following way:</p>\n\n<ol>\n\t<li>Ask the user to provide the initial state of the 3x3 table with the first input line. This\u00a0must include nine\u00a0symbols that can be\u00a0<code>X</code>, <code>O</code>\u00a0or\u00a0<code>_</code>\u00a0(the\u00a0latter represents an empty cell).</li>\n\t<li>Output the specified\u00a03x3 table before the user makes a\u00a0move.</li>\n\t<li>Request that the user enters the coordinates of the move they wish to make.</li>\n\t<li>The user then\u00a0inputs two numbers representing the cell in which they wish to place their\u00a0<code>X</code> or <code>O</code>. The game always starts with <code>X</code>, so the user's move should be made with this symbol if there are\u00a0an equal number of <code>X</code>'s and <code>O</code>'s in the table. If the table contains\u00a0an extra\u00a0<code>X</code>, the\u00a0move should be made with\u00a0<code>O</code>.</li>\n\t<li>Analyze the user input and show messages in the following situations:<br>\n\t\u2022\u00a0<code>This cell is occupied! Choose another one!</code>\u00a0\u2014 if the cell is not empty;<br>\n\t\u2022\u00a0<code>You should enter numbers!</code>\u00a0\u2014 if the user tries to enter letters or symbols instead of numbers;<br>\n\t\u2022\u00a0<code>Coordinates should be from 1 to 3!</code>\u00a0\u2014 if the user attempts to enter coordinates outside of the table's range.</li>\n\t<li>Display the table again with the user's most recent move included.</li>\n\t<li>Output the\u00a0state of the game.</li>\n</ol>\n\n<p>The possible states are:</p>\n\n<ul>\n\t<li><code>Game not finished</code>\u00a0\u2014 when no side has three in a row, but the table still\u00a0has empty cells;</li>\n\t<li><code>Draw</code>\u00a0\u2014 when no side has three in a row, and the table is complete;</li>\n\t<li><code>X wins</code>\u00a0\u2014 when there are three <code>X</code>'s in a row (up, down, across, or diagonally);</li>\n\t<li><code>O wins</code>\u00a0\u2014 when there are three <code>O</code>'s in a row (up, down, across, or diagonally).</li>\n</ul>\n\n<p>If the user provides invalid\u00a0coordinates, the program should repeat the request until numbers that represent an empty cell on the table are supplied.\u00a0You should ensure that the program only outputs the table twice \u2014 before the move and after the user makes a legal move.</p>\n\n<h2 style=\"text-align: center;\">Examples</h2>\n\n<p>The examples below show how your program should work.<br>\nThe greater-than symbol followed by a space (<code>&gt;\u00a0</code>) represents the user input. Note that it's not part of the input.</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; _XXOO_OX_\n---------\n|   X X |\n| O O   |\n| O X   |\n---------\nEnter the coordinates: &gt; 3 1\nThis cell is occupied! Choose another one!\nEnter the coordinates: &gt; one\nYou should enter numbers!\nEnter the coordinates: &gt; one three\nYou should enter numbers!\nEnter the coordinates: &gt; 4 1\nCoordinates should be from 1 to 3!\nEnter the coordinates: &gt; 1 1\n---------\n| X X X |\n| O O   |\n| O X   |\n---------\nX wins</code></pre>\n\n<p><strong>Example 2:\u00a0</strong></p>\n\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; XX_XOXOO_\n---------\n| X X   |\n| X O X |\n| O O   |\n---------\nEnter the coordinates: &gt; 3 3\n---------\n| X X   |\n| X O X |\n| O O O |\n---------\nO wins</code></pre>\n\n<p><strong>Example 3:\u00a0</strong></p>\n\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt; OX_XOOOXX\n---------\n| O X   |\n| X O O |\n| O X X |\n---------\nEnter the coordinates: &gt; 1 3\n---------\n| O X X |\n| X O O |\n| O X X |\n---------\nDraw</code></pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><code class=\"language-no-highlight\">Enter the cells: &gt;  _XO_OX___\n---------\n|   X O |\n|   O X |\n|       |\n---------\nEnter the coordinates: &gt; 3 1\n---------\n|   X O |\n|   O X |\n| X     |\n---------\nGame not finished</code></pre>",
    "description_format": "HTML",
    "files": [
      {
        "name": "tests.py",
        "placeholders": [],
        "is_visible": false,
        "text": "from test.tests import TicTacToeTests\n\nif __name__ == '__main__':\n    TicTacToeTests().run_tests()\n"
      },
      {
        "name": "test/tests.py",
        "placeholders": [],
        "is_visible": false,
        "text": "from hstest import CheckResult, StageTest, dynamic_test, TestedProgram\n\nfrom util.grid import Grid\n\n\nclass Test:\n    def __init__(self, inp, result, state, additional_contains=None):\n        self.inp = inp\n        self.result = result\n        self.state = state\n        self.additional_contains = additional_contains\n\n\nclass TicTacToeTests(StageTest):\n    test_cases = [\n        Test(\"_XXOO_OX_\\n1 1\", \"XXXOO_OX_\", \"X wins\"),\n        Test(\"_XXOO_OX_\\n1 3\\n1 1\", \"XXXOO_OX_\", \"X wins\", \"This cell is occupied! Choose another one!\"),\n        Test(\"_XXOO_OX_\\n1 4\\n1 1\", \"XXXOO_OX_\", \"X wins\", \"Coordinates should be from 1 to 3!\"),\n        Test(\"_XXOO_OX_\\none\\n1 1\", \"XXXOO_OX_\", \"X wins\", \"You should enter numbers!\"),\n        Test(\"_XXOO_OX_\\none three\\n1 1\", \"XXXOO_OX_\", \"X wins\", \"You should enter numbers!\"),\n        Test(\"_XXOO_OX_\\n2 3\", \"_XXOOXOX_\", \"Game not finished\"),\n        Test(\"_XXOO_OX_\\n3 3\", \"_XXOO_OXX\", \"Game not finished\"),\n        Test(\"XX_XOXOO_\\n1 3\", \"XXOXOXOO_\", \"O wins\"),\n        Test(\"XX_XOXOO_\\n3 3\", \"XX_XOXOOO\", \"O wins\"),\n        Test(\"_XO_OX___\\n1 1\", \"XXO_OX___\", \"Game not finished\"),\n        Test(\"_XO_OX___\\n2 1\", \"_XOXOX___\", \"Game not finished\"),\n        Test(\"_XO_OX___\\n3 1\", \"_XO_OXX__\", \"Game not finished\"),\n        Test(\"_XO_OX___\\n3 2\", \"_XO_OX_X_\", \"Game not finished\"),\n        Test(\"_XO_OX___\\n3 3\", \"_XO_OX__X\", \"Game not finished\"),\n        Test(\"_XO_OX__X\\n1 1\", \"OXO_OX__X\", \"Game not finished\"),\n        Test(\"_XO_OX__X\\n2 1\", \"_XOOOX__X\", \"Game not finished\"),\n        Test(\"_XO_OX__X\\n3 1\", \"_XO_OXO_X\", \"O wins\"),\n        Test(\"_XO_OX__X\\n3 2\", \"_XO_OX_OX\", \"Game not finished\"),\n        Test(\"XO_OXOX__\\n1 3\", \"XOXOXOX__\", \"X wins\"),\n        Test(\"XO_OXOX__\\n3 2\", \"XO_OXOXX_\", \"Game not finished\"),\n        Test(\"XO_OXOX__\\n3 3\", \"XO_OXOX_X\", \"X wins\"),\n    ]\n\n    @dynamic_test(data=test_cases)\n    def test_grid_output(self, test):\n        program = TestedProgram()\n        program.start()\n\n        output = program.execute(test.inp)\n\n        grid = Grid.from_line(test.inp.split('\\n')[0])\n        output_grid = Grid.from_output(output)\n\n        if grid != output_grid:\n            return CheckResult.wrong(\"The printed grid is not equal to the input grid!\\n\"\n                                     \"Correct grid:\\n\\n\" + str(grid))\n\n        if test.additional_contains is not None and test.additional_contains not in output:\n            return CheckResult.wrong(\"'{}' expected in the output!\".format(test.additional_contains))\n\n        result_grid = Grid.from_output(output, 2)\n        correct_result_grid = Grid.from_line(test.result)\n\n        if result_grid != correct_result_grid:\n            return CheckResult.wrong(\n                f\"The printed result grid is not correct!\\nCorrect result grid:\\n\\n {correct_result_grid}\")\n\n        if test.state not in output:\n            return CheckResult.wrong(f\"The game result is wrong. Expected result '{test.state}'\")\n\n        return CheckResult.correct()\n\n\nif __name__ == '__main__':\n    TicTacToeTests().run_tests()\n"
      },
      {
        "name": "tictactoe.py",
        "placeholders": [],
        "is_visible": true,
        "text": "# write your code here\n"
      },
      {
        "name": "test/__init__.py",
        "placeholders": [],
        "is_visible": false,
        "text": ""
      }
    ],
    "samples": null,
    "execution_memory_limit": null,
    "execution_time_limit": null,
    "limits": null,
    "code_templates": null,
    "format_version": 16,
    "custom_name": "stage1",
    "solution_hidden": null,
    "code_templates_header_lines_count": null,
    "code_templates_footer_lines_count": null,
    "hyperskill": {
      "files": [
        {
          "name": "util/enum.py",
          "is_visible": true,
          "text": "from enum import Enum\nfrom hstest import WrongAnswer\n\n\nclass GameState(Enum):\n    X_WIN = 'X_WIN'\n    O_WIN = 'O_WIN'\n    DRAW = 'DRAW'\n    NOT_FINISHED = 'NOT_FINISHED'\n\n\nclass CellState(Enum):\n    X = 'X'\n    O = 'O'\n    EMPTY = ' '\n\n    @classmethod\n    def get(cls, char: str):\n\n        char_to_cell_state = {\n            'X': cls.X,\n            'O': cls.O,\n            ' ': cls.EMPTY,\n            '_': cls.EMPTY\n        }\n\n        if char not in char_to_cell_state:\n            raise WrongAnswer('Bad symbol ' + char + ' in the game grid')\n        return char_to_cell_state[char]\n\n    @classmethod\n    def get_opponent(cls, player):\n        if player == CellState.X:\n            return CellState.O\n        if player == CellState.O:\n            return CellState.X\n        raise Exception('Wrong method argument!')\n"
        },
        {
          "name": "util/grid.py",
          "is_visible": true,
          "text": "from hstest import WrongAnswer\nfrom util.minimax import Position\nfrom util.enum import CellState, GameState\nfrom copy import copy\n\n\nclass Grid:\n    def __init__(self):\n        self.__grid = [[CellState.EMPTY for _ in range(3)] for _ in range(3)]\n\n    def get_grid(self):\n        return self.__grid\n\n    @classmethod\n    def from_line(cls, line):\n        if len(line) != 9:\n            raise WrongAnswer(\"Wrong input length. Expected 9.\\nFound \" + str(len(line)))\n\n        grid = Grid()\n\n        for i, char in enumerate(line):\n            grid.__grid[(int(i / 3))][i % 3] = CellState.get(char)\n\n        return grid\n\n    @classmethod\n    def from_output(cls, string_field: str, field_number: int = 1):\n        grid = Grid()\n\n        field_lines = list(map(str.strip, string_field.splitlines()))\n        field_lines = list(filter(lambda field_line:\n                                  str(field_line).startswith('|') and str(field_line).endswith('|'),\n                                  field_lines))\n\n        if len(field_lines) < 3 * field_number:\n            raise WrongAnswer(\"Expected not less than \" + str(field_number) + \" grids in the output!\\n\" +\n                              \"Make sure you print the game grids in the correct format!\")\n\n        field_lines = field_lines[field_number * 3 - 3:field_number * 3]\n\n        for i, line in enumerate(field_lines):\n            if len(line) != 9:\n                raise WrongAnswer(\"Can't parse the game field. The following line has wrong length:\\n\" + line)\n            for j in range(3):\n                grid.__grid[i][j] = CellState.get(line[j * 2 + 2])\n\n        return grid\n\n    @classmethod\n    def all_grids_from_output(cls, string_field: str):\n\n        grid_list = list()\n\n        field_lines = list(map(str.strip, string_field.splitlines()))\n        field_lines = list(filter(lambda field_line:\n                                  str(field_line).startswith('|') and str(field_line).endswith('|'),\n                                  field_lines))\n\n        if len(field_lines) % 3 != 0:\n            raise WrongAnswer(\n                \"Wrong grid output format! Each grid should contain 3 lines that starts and ends with '|' symbol!\")\n\n        for i in range(len(field_lines) // 3):\n            grid_lines = field_lines[i * 3:i * 3 + 3]\n\n            grid = Grid()\n\n            for j, line in enumerate(grid_lines):\n                if len(line) != 9:\n                    raise WrongAnswer(\"Can't parse the game field. The following line has wrong length:\\n\" + line)\n                for k in range(3):\n                    grid.__grid[j][k] = CellState.get(line[k * 2 + 2])\n\n            grid_list.append(grid)\n\n        return grid_list\n\n    @classmethod\n    def get_move(cls, from_grid, to_grid):\n        for i in range(3):\n            for j in range(3):\n                if from_grid.__grid[i][j] != to_grid.__grid[i][j]:\n                    return Position(i, j)\n        raise WrongAnswer(\"After making a move the grid was the same!\")\n\n    def is_win(self, player) -> bool:\n        for i in range(3):\n            if self.__grid[i][0] == self.__grid[i][1] and self.__grid[i][1] == self.__grid[i][2] and self.__grid[i][\n                2] == player:\n                return True\n\n        for i in range(3):\n            if self.__grid[0][i] == self.__grid[1][i] and self.__grid[1][i] == self.__grid[2][i] and self.__grid[2][\n                i] == player:\n                return True\n\n        return (self.__grid[0][0] == self.__grid[1][1] and self.__grid[1][1] == self.__grid[2][2] and self.__grid[2][\n            2] == player) or (self.__grid[2][0] == self.__grid[1][1] and self.__grid[1][1] == self.__grid[0][2] and\n                              self.__grid[0][2] == player)\n\n    def has_empty_cells(self):\n        for cells in self.__grid:\n            for cell in cells:\n                if cell == CellState.EMPTY:\n                    return True\n\n    def get_num_of_empty_cells(self):\n        result = 0\n        for cells in self.__grid:\n            for cell in cells:\n                if cell == CellState.EMPTY:\n                    result += 1\n        return result\n\n    def get_game_state(self):\n        if self.is_win(CellState.X):\n            return GameState.X_WIN\n        if self.is_win(CellState.O):\n            return GameState.O_WIN\n        if self.has_empty_cells():\n            return GameState.NOT_FINISHED\n        return GameState.DRAW\n\n    def set_cell(self, x, y, cell_state):\n        self.__grid[x][y] = cell_state\n\n    def is_correct_next_grid(self, grid):\n        return self.get_num_of_empty_cells() - grid.get_num_of_empty_cells() == 1\n\n    def is_valid_grid(self):\n        num_of_o = 0\n        num_of_x = 0\n        for cells in self.__grid:\n            for cell in cells:\n                if cell == CellState.O:\n                    num_of_o += 1\n                elif cell == CellState.X:\n                    num_of_x += 1\n        return abs(num_of_x - num_of_o) <= 1\n\n    @classmethod\n    def check_grid_sequence(cls, grids):\n\n        if len(grids) <= 1:\n            return\n\n        for i in range(1, len(grids) - 1):\n            prev_grid = grids[i - 1]\n            grid = grids[i]\n\n            if not grid.is_valid_grid():\n                raise WrongAnswer(\n                    \"Impossible grid was printed! The difference between Os and Xs in the grid is greater than 1:\\n\" + str(\n                        grid))\n\n            if not prev_grid.is_correct_next_grid(grid):\n                raise WrongAnswer(\"After making a move on grid\\n\" + str(prev_grid) + \"\\n it can't become\\n\" + str(grid))\n\n            last_grid = grids[-1]\n\n            if last_grid.get_game_state() == GameState.NOT_FINISHED:\n                raise WrongAnswer(\"Last grid is not terminal!\\n\" + str(last_grid))\n\n    def __str__(self):\n        result = '---------\\n'\n        for cell in self.__grid:\n            result += '| {} {} {} |\\n'.format(cell[0].value, cell[1].value, cell[2].value)\n        result += '---------'\n        return result\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return False\n\n        for i in range(9):\n            if self.__grid[int(i / 3)][i % 3] != other.__grid[int(i / 3)][i % 3]:\n                return False\n        return True\n"
        },
        {
          "name": "util/minimax.py",
          "is_visible": true,
          "text": "from util.enum import GameState, CellState\n\n\nclass Position:\n\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return str(self.x) + \" \" + str(self.y)\n\n    def __eq__(self, other):\n        return other.x == self.x and other.y == self.y\n\n\nclass Minimax:\n\n    @classmethod\n    def minimax(cls, grid, player, is_maximize, start_player, depth):\n\n        game_state = grid.get_game_state()\n\n        if game_state == GameState.X_WIN:\n            return 10 - depth if start_player == CellState.X else depth - 10\n        elif game_state == GameState.O_WIN:\n            return 10 - depth if start_player == CellState.O else depth - 10\n        elif game_state == GameState.DRAW:\n            return 0\n\n        best_score = -999 if is_maximize else 999\n\n        for i in range(3):\n            for j in range(3):\n                if grid.get_grid()[i][j] == CellState.EMPTY:\n                    grid.set_cell(i, j, player)\n                    score = cls.minimax(grid, CellState.get_opponent(player), not is_maximize, start_player, depth + 1)\n                    grid.set_cell(i, j, CellState.EMPTY)\n                    best_score = max(best_score, score) if is_maximize else min(best_score, score)\n\n        return best_score\n\n    @classmethod\n    def get_move(cls, grid, player):\n        best_score = -999\n        best_position = None\n\n        for i in range(3):\n            for j in range(3):\n                if grid.get_grid()[i][j] == CellState.EMPTY:\n                    grid.set_cell(i, j, player)\n                    score = cls.minimax(grid, CellState.get_opponent(player), False, player, 1)\n                    grid.set_cell(i, j, CellState.EMPTY)\n                    if score > best_score:\n                        best_score = score\n                        best_position = Position(i, j)\n\n        return best_position\n\n    @classmethod\n    def get_available_positions(cls, grid, player):\n\n        positions = list()\n\n        for i in range(3):\n            for j in range(3):\n                if grid.get_grid()[i][j] == CellState.EMPTY:\n                    grid.set_cell(i, j, player)\n                    score = cls.minimax(grid, CellState.get_opponent(player), False, player, 1)\n                    if score >= 0:\n                        positions.append(Position(i, j))\n                    grid.set_cell(i, j, CellState.EMPTY)\n\n        return positions\n"
        },
        {
          "name": "util/__init__.py",
          "is_visible": true,
          "text": ""
        },
        {
          "name": "requirements.txt",
          "is_visible": true,
          "text": "https://github.com/hyperskill/hs-test-python/archive/release.tar.gz\n"
        }
      ]
    }
  }
 }
